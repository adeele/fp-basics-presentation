import { Head, Appear, Image } from 'mdx-deck'
import { Split } from 'mdx-deck/layouts'

import yellow from '@mdx-deck/themes/yellow'
import highlight from '@mdx-deck/themes/syntax-highlighter-prism'

import './styles.css'

export const themes = [yellow, highlight]

<Head>
  <title>Functional programming</title>
</Head>

# Functional programming
### - Basics -

Adrianna Ma≈Çkiewicz

---

## Agenda

<ol>
  <Appear>
    <li>
        Introduction to functional programming
        <ul>
            <li>
                paradigm characteristics
            </li>
            <li>
                comparison to imperative programming
            </li>
        </ul>
    </li>
    <li>
        Pros and cons of functional programming
        <ul>
            <li>
                should I use...
            </li>
            <li>
                ...and if so, when?
            </li>
        </ul>
    </li>
    <li>
        Functional programming in JS
        <ul>
            <li>
                concepts
            </li>
            <li>
                best practices
            </li>
        </ul>
    </li>
  </Appear>
</ol>

---

## Introduction to functional programming

Functional programming treats computation as the evaluation of mathematical functions.
Programming is done with expressions or declarations instead of statements.

[Wikipedia](https://en.wikipedia.org/wiki/Functional_programming)

---

<Image src="static/meme4.jpg" width="1200px" height="600px" />

---

### Paradigm characteristics

<ul>
  <Appear>
    <li>
        <b>Statelessness</b> - an operation is not sensitive to the state of the computation
    </li>
    <li>
        <b>Referential transparency</b> - an expression can be replaced with its corresponding value without changing the
        program's behavior
    </li>
    <li>
        <b>Immutability</b> - an object whose state cannot be modified after it is created
    </li>
  </Appear>
</ul>

---

### Comparison to imperative programming

<Split>
<div>

Imperative
```js
const sum = (list) => {
    let result = 0;
    for (element of list) {
        result += element;
    }
    return result;
}
```

</div>
<div>

Declarative
```js
const sum = (list) => {
    const add = ((x, y) => x + y);
    return list.reduce(add, 0);
}
```

</div>
</Split>

---

<Image src="static/meme1.png" width="600px" height="600px" />

---

## Pros and cons of functional programming

<Image src="static/meme2.jpg" width="auto" height="600px" />

---

<Split>
    <div>
        Advantages
        <ul>
            <li>
                more predictable code
            </li>
            <li>
                less verbose code
            </li>
            <li>
                less error-prone
            </li>
            <li>
                easier to test
            </li>
            <li>
                easily reusable code
            </li>
            <li>
                faster to write code
            </li>
        </ul>
    </div>
    <div>
        Disadvantages
        <ul>
            <li>
                worse performance
            </li>
            <li>
                complex function compositions
            </li>
            <li>
                obscured by advanced math terminology
            </li>
            <li>
                some features are impossible to implement
            </li>
        </ul>
    </div>
</Split>

---

### Should I use...

<Image src="static/meme.gif" width="600px" height="600px" />

---

### ...and if so, when?

<ul>
<Appear>
<li>
For quick prototyping
</li>
<li>
In math-based projects
</li>
<li>

[If there are no restricted requirements on performance](https://www.youtube.com/watch?v=PhUb7y9WZGs)

</li>
</Appear>
</ul>

---

## Functional programming in JS

<Image src="static/meme3.png" width="auto" height="600px" />

---

### Concepts

**Pure functions** - function which has no side effects and its return value is the same for the same arguments.

**Referential transparency** - an expression can be replaced with its corresponding value without changing the program's
behavior

<Split>
<div>

Imperative
```js
let x = 1;
x = x + 1; // 2
x = x + 1; // 3
```

</div>
<div>

Declarative
```js
const plusOne = (x) => x + 1;
plusOne(1); // 2
plusOne(1); // 2

```

</div>
</Split>

---

### Concepts

**Higher-order functions** - passing functions as arguments to other functions or returning functions as results from
other functions

<Split>
<div>

Custom function composition
```js
const twice = (x, y) => x(x(y));
const add3 = (x) => x + 3;
twice(add3, 1); // 7

```

</div>
<div>

* map
* filter
* reduce

</div>
</Split>

---

### Concepts

**Anonymous function** - a function definition that is not bound to an identifier

```js
const twice = (x, y) => x(x(y));
twice((x) => x + 3, 1); // 7

```

---

### Concepts

**Nested function** - a function which is defined within another function

**Non-local variable** - a variable that is not defined in the local scope, but also not necessarily in the global one.

**Closure** - a record storing a function together with an environment.

<Split>

```js
const doubleSum = (x, y) => {
    const sum = (x, y) => x + y;
    return sum(x, y) * 2;
};
doubleSum(1, 2); // 6
```

```js
const sum = (a) => (b) => a + b;
const add5 = sum(5);
add5(10); // 15

```

</Split>

---

### Concepts

**Recursion** - a method of solving a problem where the solution depends on solutions to smaller instances of the same
problem (as opposed to iteration)

```js
const factorial = (n) => {
    if (n <= 0) {
        return 1;
    }
    return n * factorial(n - 1);
}
factorial(10); // 3628800

```

---


## Questions

---

Thank you
